if not LPH_OBFUSCATED then
    LPH_NO_VIRTUALIZE = function(f) return f end;
    LPH_JIT = function(f) return f end;
    LPH_CRASH = function() while true do end end;
end;

local MaidSource = game:HttpGet("https://raw.githubusercontent.com/AccountBurner/Utility/refs/heads/main/Maid.lua");
local SignalSource = game:HttpGet("https://raw.githubusercontent.com/AccountBurner/Utility/refs/heads/main/Signal");
local ServicesSource = game:HttpGet("https://raw.githubusercontent.com/AccountBurner/Utility/refs/heads/main/Services");

local Maid = loadstring(MaidSource)();
local Signal = loadstring(SignalSource)();
local Services = loadstring(ServicesSource)();

local TweenService, UserInputService = Services:Get('TweenService', 'UserInputService');

local Notification = {};
Notification.__index = Notification;
Notification.NotifGap = 25;

local viewportSize = workspace.CurrentCamera.ViewportSize;
local notifications = {};
local isMoving = false;

local MODERN_COLORS = {
    background = Color3.fromRGB(35, 35, 40);
    border = Color3.fromRGB(55, 55, 65);
    accent = Color3.fromRGB(255, 140, 0);
    text = Color3.fromRGB(240, 240, 240);
    shadow = Color3.fromRGB(0, 0, 0);
};

local TWEEN_INFO = {
    in_out = TweenInfo.new(0.4, Enum.EasingStyle.Quart, Enum.EasingDirection.Out);
    progress = TweenInfo.new(1, Enum.EasingStyle.Linear);
    slide = TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out);
};

function Notification.new(config)
    local options = type(config) == "table" and config or {text = tostring(config)};
    
    local self = setmetatable({
        _options = {
            text = options.text or "Notification";
            duration = options.duration or 4;
            icon = options.icon;
            color = options.color or MODERN_COLORS.accent;
        };
        _maid = Maid.new();
        _tweens = {};
        _destroyed = false;
    }, Notification);
    
    self.Destroying = Signal.new();
    self._maid:AddTask(self.Destroying);
    
    task.spawn(function() self:_init() end);
    return self;
end;

function Notification:_createDrawing(type, props)
    local instance = Drawing.new(type);
    for k, v in pairs(props) do
        instance[k] = v;
    end;
    self._maid:AddTask(instance);
    return instance;
end;

function Notification:_getTextBounds(text, size)
    local temp = Drawing.new('Text');
    temp.Text = text;
    temp.Size = size;
    local bounds = temp.TextBounds;
    temp:Remove();
    return bounds;
end;

-- Fixed tween method using custom property tweening for Drawing objects
function Notification:_tweenProperty(instance, property, target, info, callback)
    local currentValue = instance[property];
    local valueType = typeof(currentValue);
    
    -- Create appropriate value object
    local valueObject = Instance.new(
        valueType == "Vector2" and "Vector3Value" or
        valueType == "Color3" and "Color3Value" or
        "NumberValue"
    );
    
    self._maid:AddTask(valueObject);
    
    -- Handle Vector2 conversion
    if valueType == "Vector2" then
        valueObject.Value = Vector3.new(currentValue.X, currentValue.Y, 0);
        target = Vector3.new(target.X, target.Y, 0);
    else
        valueObject.Value = currentValue;
    end;
    
    local tween = TweenService:Create(valueObject, info, {Value = target});
    self._tweens[tween] = true;
    
    local connection = valueObject:GetPropertyChangedSignal('Value'):Connect(function()
        if self._destroyed then return end;
        
        local newValue = valueObject.Value;
        if valueType == "Vector2" then
            newValue = Vector2.new(newValue.X, newValue.Y);
        end;
        
        instance[property] = newValue;
    end);
    
    self._maid:AddTask(connection);
    
    if callback then
        self._maid:AddTask(tween.Completed:Connect(callback));
    end;
    
    self._maid:AddTask(tween);
    tween:Play();
    return tween;
end;

function Notification:_init()
    local textBounds = self:_getTextBounds(self._options.text, 16);
    local padding = Vector2.new(25, 15);
    local frameSize = textBounds + padding;
    
    if self._options.icon then frameSize += Vector2.new(20, 0) end;
    
    local startPos = viewportSize + Vector2.new(10, -frameSize.Y - 10);
    local endPos = viewportSize - Vector2.new(frameSize.X + 10, frameSize.Y + 10);
    
    -- Create UI elements
    self._shadow = self:_createDrawing('Square', {
        Size = frameSize + Vector2.new(4, 4);
        Position = startPos + Vector2.new(2, 2);
        Color = MODERN_COLORS.shadow;
        Transparency = 0.7;
        Filled = true;
    });
    
    self._frame = self:_createDrawing('Square', {
        Size = frameSize;
        Position = startPos;
        Color = MODERN_COLORS.background;
        Filled = true;
    });
    
    self._border = self:_createDrawing('Square', {
        Size = frameSize;
        Position = startPos;
        Color = MODERN_COLORS.border;
        Filled = false;
        Thickness = 1;
    });
    
    self._accent = self:_createDrawing('Square', {
        Size = Vector2.new(3, frameSize.Y);
        Position = startPos;
        Color = self._options.color;
        Filled = true;
    });
    
    local textX = self._options.icon and 35 or 15;
    self._text = self:_createDrawing('Text', {
        Text = self._options.text;
        Size = 16;
        Color = MODERN_COLORS.text;
        Position = startPos + Vector2.new(textX, frameSize.Y / 2 - textBounds.Y / 2);
        Font = Drawing.Fonts.UI;
    });
    
    if self._options.icon then
        self._icon = self:_createDrawing('Text', {
            Text = self._options.icon;
            Size = 18;
            Color = self._options.color;
            Position = startPos + Vector2.new(12, frameSize.Y / 2 - 9);
            Font = Drawing.Fonts.UI;
        });
    end;
    
    if self._options.duration then
        self._progress = self:_createDrawing('Square', {
            Size = Vector2.new(frameSize.X, 2);
            Position = startPos + Vector2.new(0, frameSize.Y - 2);
            Color = self._options.color;
            Filled = true;
        });
    end;
    
    -- Add to notifications list and move others up
    table.insert(notifications, self);
    self:_moveAllUp();
    
    -- Calculate target position
    local targetPos = endPos - Vector2.new(0, (#notifications - 1) * Notification.NotifGap);
    
    -- Animate in
    self:_tweenProperty(self._shadow, 'Position', targetPos + Vector2.new(2, 2), TWEEN_INFO.slide);
    self:_tweenProperty(self._frame, 'Position', targetPos, TWEEN_INFO.slide);
    self:_tweenProperty(self._border, 'Position', targetPos, TWEEN_INFO.slide);
    self:_tweenProperty(self._accent, 'Position', targetPos, TWEEN_INFO.slide);
    
    local textPos = targetPos + Vector2.new(textX, frameSize.Y / 2 - textBounds.Y / 2);
    self:_tweenProperty(self._text, 'Position', textPos, TWEEN_INFO.slide);
    
    if self._icon then
        local iconPos = targetPos + Vector2.new(12, frameSize.Y / 2 - 9);
        self:_tweenProperty(self._icon, 'Position', iconPos, TWEEN_INFO.slide);
    end;
    
    if self._progress then
        local progressPos = targetPos + Vector2.new(0, frameSize.Y - 2);
        self:_tweenProperty(self._progress, 'Position', progressPos, TWEEN_INFO.slide, function()
            self:_tweenProperty(self._progress, 'Size', Vector2.new(0, 2), 
                TweenInfo.new(self._options.duration, Enum.EasingStyle.Linear), 
                function() self:Destroy() end);
        end);
    end;
end;

function Notification:_moveAllUp()
    if isMoving then return end;
    isMoving = true;
    
    local moveDistance = Vector2.new(0, -Notification.NotifGap);
    
    for i, notif in ipairs(notifications) do
        if notif ~= self and not notif._destroyed then
            notif:_cancelTweens();
            
            local elements = {notif._shadow, notif._frame, notif._border, notif._accent, notif._text};
            if notif._icon then table.insert(elements, notif._icon) end;
            if notif._progress then table.insert(elements, notif._progress) end;
            
            for _, element in ipairs(elements) do
                if element then
                    element.Position = element.Position + moveDistance;
                end;
            end;
        end;
    end;
    
    task.wait(0.01);
    isMoving = false;
end;

function Notification:_cancelTweens()
    for tween in pairs(self._tweens) do
        if tween.PlaybackState == Enum.PlaybackState.Playing then
            tween:Cancel();
        end;
    end;
end;

function Notification:_mouseInFrame()
    local mouse = UserInputService:GetMouseLocation();
    local pos = self._frame.Position;
    local size = self._frame.Size;
    return mouse.X >= pos.X and mouse.X <= pos.X + size.X and 
           mouse.Y >= pos.Y and mouse.Y <= pos.Y + size.Y;
end;

function Notification:Destroy()
    if self._destroyed then return end;
    self._destroyed = true;
    
    self.Destroying:Fire();
    
    local index = table.find(notifications, self);
    if index then table.remove(notifications, index) end;
    
    self:_cancelTweens();
    
    local slideOut = viewportSize + Vector2.new(10, 0);
    self:_tweenProperty(self._frame, 'Position', slideOut, TWEEN_INFO.in_out, function()
        self._maid:Clean();
    end);
    
    if self._shadow then self:_tweenProperty(self._shadow, 'Position', slideOut + Vector2.new(2, 2)); end;
    if self._border then self:_tweenProperty(self._border, 'Position', slideOut); end;
    if self._accent then self:_tweenProperty(self._accent, 'Position', slideOut); end;
    if self._text then self:_tweenProperty(self._text, 'Position', slideOut + Vector2.new(15, 10)); end;
    if self._icon then self:_tweenProperty(self._icon, 'Position', slideOut + Vector2.new(12, 10)); end;
    if self._progress then self:_tweenProperty(self._progress, 'Position', slideOut + Vector2.new(0, 20)); end;
    
    task.wait(0.1);
    self:_moveAllUp();
end;

local function onInput(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        for _, notif in ipairs(notifications) do
            if notif:_mouseInFrame() then
                notif:Destroy();
                break;
            end;
        end;
    end;
end;

UserInputService.InputBegan:Connect(onInput);

return setmetatable({
    new = Notification.new;
    create = Notification.new;
}, {
    __call = function(_, ...)
        return Notification.new(...);
    end;
});
